'From Squeak5.1 of 5 September 2016 [latest update: #16549] on 27 November 2017 at 4:17:05 am'!Object subclass: #Rational	instanceVariableNames: 'numerator denominator distance time mass'	classVariableNames: ''	poolDictionaries: ''	category: 'UserObjects'!!Rational methodsFor: 'internal methods' stamp: 'dkm 11/27/2017 01:22'!gcd: x number2: y		|a b |		a := x.		b := y.		[(b = 0) not] 		whileTrue: [ |r|  			r := a rem: y.			a := b.			b := r].		^a! !!Rational methodsFor: 'internal methods' stamp: 'dkm 11/27/2017 01:23'!simplify		|g|		g:= self gcd: numerator number2: denominator.		numerator := numerator/g.		denominator := denominator/g.! !!Rational methodsFor: 'accesors' stamp: 'dkm 11/27/2017 01:24'!getDenominator		^denominator! !!Rational methodsFor: 'accesors' stamp: 'dkm 11/27/2017 01:25'!getDistance^distance! !!Rational methodsFor: 'accesors' stamp: 'dkm 11/27/2017 01:29'!getMass	^mass! !!Rational methodsFor: 'accesors' stamp: 'dkm 11/27/2017 01:28'!getNumerator^numerator! !!Rational methodsFor: 'accesors' stamp: 'dkm 11/27/2017 01:29'!getTime	^time! !!Rational methodsFor: 'printing' stamp: 'dkm 11/27/2017 01:30'!printRational		^(numerator printString), '/', (denominator printString)	! !!Rational methodsFor: 'operation' stamp: 'dkm 11/27/2017 01:32'!add: aNumerator den: aDenominator dist: aDistance tm: aTime ms: aMass	"add two rationals"((aDistance = distance) & (aTime = time) & (aMass = mass)) 		ifTrue: [		| num den result |		num := (numerator * aDenominator) + (denominator * aNumerator).		den := denominator * aDenominator.		result := self new num den distance time mass.		result simplify.		^result		]		ifFalse:[			self error: 'The rationals do not have equivalent dimmensions'		].! !!Rational methodsFor: 'operation' stamp: 'dkm 11/27/2017 03:15'!divide:  aNumerator den: aDenominator dist: aDistance tm: aTime ms: aMass|newNum newDen newDist newTime newMass result|newNum:= aDenominator * self numerator.newDen:= aNumerator* self denominator.newDist:= aDistance - self distance.newTime:= aTime - self time.newMass:= aMass - self mass.result:=(Rational new)num: newNum den: newDen dist: newDist tm: newTime ms: newMass.result simplify.^result! !!Rational methodsFor: 'operation' stamp: 'dkm 11/27/2017 02:37'!multiply: aNumerator den: aDenominator dist: aDistance tm: aTime ms: aMass! !!Rational methodsFor: 'operation' stamp: 'dkm 11/27/2017 02:28'!subtract: aNumerator den: aDenominator dist: aDistance tm: aTime ms: aMass	"subtract two rationals"((aDistance = distance) & (aTime = time) & (aMass = mass)) 		ifTrue: [		| num den result |		num := (numerator * aDenominator) - (denominator * aNumerator).		den := denominator * aDenominator.		result := self new num den distance time mass.		result simplify.		^result		]		ifFalse:[			self error: 'The rationals do not have equivalent dimmensions'		].! !!Rational methodsFor: 'initialize' stamp: 'dkm 11/27/2017 01:52'!init: num number2: den unit1: dist unit2: tm unit3: ms	"initialize a Rational"den = 0		ifTrue: [self error: 'The number 0 cannot be in the denominator'].		(num isKindOf: Integer)	ifFalse:[ self error: 'The number in the numerator must be an integer'].		(den isKindOf: Integer)		ifFalse:[self error: 'The number in the denominator must be an integer'].				numerator:= num.		denominator := den.		distance := dist.		time := tm.		mass := ms.! !!Rational methodsFor: 'initialize' stamp: 'dkm 11/27/2017 02:26'!new: numerator number2: denominator dst: distance t:  time m: mass	"create a Rational"	| d |		d := self init: numerator num2: denominator num3: distance num4:  time num5: mass.		^d! !